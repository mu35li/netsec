\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{minted}
\usepackage[left=1.2cm, right=1.2cm, top=1.5cm, bottom=2cm]{geometry}
\usepackage{url}
\usepackage{graphicx}


\setcounter{section}{1}
\author{Julian Deinert, Tronje Krabbe}
\title{Labreport 06}
\linespread{1.0}
\begin{document}
\maketitle
\tableofcontents
\thispagestyle{empty}
\newpage
\setcounter{page}{1}


\section*{1. TODO}
\addcontentsline{toc}{section}{1. TODO}
\setcounter{subsection}{1}

\subsection{}
TODO

\setcounter{section}{2}
\section*{2. TODO}
\addcontentsline{toc}{section}{2. TODO}
\setcounter{subsection}{0}
\subsection{}
\subsection{}
        Um ein selbstsigniertes Zertifikat zu erzeugen, sind die folgenden Befehle notwendig:

        \begin{verbatim}
			openssl genrsa -out server.key 2048
			openssl req -new -key server.key -out server.csr
			openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
        \end{verbatim}

        Mit dem ersten Befehl erzeugen wir einen neuen, 
        2048-bit langen privaten
        Schlüssel. 
        Der zweite Befehl erstellt die
        \textit{certificate signing request}, 
        in der die Informationen enthalten
        sind, die das Zertifikat später umfassen soll. 
        Diese werden interaktiv
        abgefragt. 
        Als Common Name verwenden wir \texttt{vmsrv12.svslab}.

        Im dritten Befehl verwenden wir schließlich 
        den erstellten Private Key,
        um aus der CSR ein Zertifikat zu generieren, 
        das 365 Tage gültig ist.

        Um dieses Zertifikat für den Apache-Server einzusetzen, ersetzen wir in
        der Konfigurationsdatei die Pfade hinter \texttt{SSLCertificateFile} und
        \texttt{SSLCertificateKeyFile} mit den Pfaden zum Zertifikat und dem
        private key.

        Um einen Missbrauch von Zertifikaten und damit auch ihre
        Wirksamkeit sicherzustellen, werden selbsterstellten Zertifikaten
        nicht vertraut. Vertrauenswürdige Zertifikate werden von
        \textit{Certificate Authorities} ausgestellt, deren Aufgabe es
        ist, rechtmäßig angefragte Zertifikate auszustellen und mit
        Glaubwürdigkeit zu versehen sowie im Umkehrschluss unglaubwürdige
        Zertifikatserstellungen zu erschweren.

\subsection{}
        Das Apache-Modul \textit{mod\_rewrite} ermöglicht Weiterleitungen einzurichten. Wir wollen alle Requests an HTTPS weiterleiten und erweitern die config daher um folgende Zeilen.
        \footnote{Quelle: \url{https://wiki.apache.org/httpd/RewriteHTTPToHTTPS}}

        \begin{verbatim}
RewriteEngine On
RewriteCond %{HTTPS} !=on
RewriteRule ^/?(.*) https://%{SERVER_NAME}/$1 [R,L]
        \end{verbatim}

        Mit dem ersten Befehl wird die Bearbeitung der Rewrite-Regeln eingeschaltet.
        Danach wird geprüft, ob nicht bereits HTTPS verwendet wird, da damit die
        Weiterleitung hinfällig wird. Schließlich wird die Rewrite-Regel definiert,
        die dann weiterleitet. Die Optionen am Ende sind die Flags. \texttt{L}
        gibt an, dass die Regel die letzte ist, die ausgeführt wird. \texttt{R}
        spezifiziert, dass ein HTTP Redirect passieren soll.

        Die Regel selbst ist ein regulärer Ausdruck, bei dem alles nach einem
        optionalen ``\texttt{/}'' matched und in die HTTPS-URL eingesetzt wird.

\subsection{}
        Über die verschlüsselte Verbindung können wir die Zugangsdaten
        selbstverständlich nicht mitlesen. Verwenden wir \textit{sslstrip} als
        Proxy, so wird die Umleitung auf die verschlüsselte Verbindung verhindert
        und wir können die Zugangsdaten recht komfortabel im Log-File nachlesen.

        Die Sicherheit der Weiterleitung ist damit maximal als ``gut gemeinte''
        Maßnahme für Endanwender gedacht, taugt aber nicht, ernsthafte Angriffe
        abzuwehren. Hierzu sind weitere Maßnahmen nötig, wie beispielsweise HSTS.

        \textit{HTTP Strict Transport Security (HSTS)} ist ein in RFC 6797%
        \footnote{\url{https://tools.ietf.org/html/rfc6797}} beschriebener
        Standard, der einen solchen Angriff verhindern kann. Wird HSTS aktiviert,
        so können Seiten unter einer Domain, die HSTS setzt, nicht über eine
        unverschlüsselte Verbindung abgerufen weden.
        HSTS wird über einen Header aktiviert, der bei der Antwort mitgesendet
        wird und etwa so aussieht:

        \begin{verbatim}
Strict-Transport-Security: max-age=15768000
        \end{verbatim}

        Damit wird HSTS im Browser strikt forciert und lässt sich auch für
        den Endnutzer nicht wieder abschalten.
        Mit dem \texttt{max-age}-Parameter wird das maximale Alter
        in Sekunden angegeben. 15768000 Sekunden entsprechen etwa einem halben
        Jahr, danach wird der Browser eine unverschlüsselte Verbindung prinzipiell
        wieder erlauben, wenn nicht erneut ein HSTS-Header mitgesendet wird.

\setcounter{section}{3}
\section*{3. Unsichere selbstenwtickelte Verschlüsselungsalgorithmen}
\addcontentsline{toc}{section}{3. Unsichere selbstenwtickelte Verschlüsselungsalgorithmen}
\setcounter{subsection}{0}
\subsection{BaziCrypt}
Die letzten 10 Bytes des Ciphertexts sind exakt der Key. Oder, genauergesagt, der Key XOR Null,
was den Key unverändert lässt. Jetzt ist es sehr einfach, die Dateien zu entschlüsseln. Siehe
unser Skript im Appendix. Die drei Plaintexte sind:
\begin{quote}[n01.txt.enc]
Hallo Peter. Endlich koennen wir geheim kommunizieren! Bis bald, Max
\end{quote}
\begin{quote}[n02.txt.enc]
Hi Max! Super, Sicherheitsbewusstsein ist ja extrem wichtig! Schoene Gruesse, Peter.
\end{quote}
\begin{quote}[n03.txt.enc]
Hi Peter, hast du einen Geheimtipp fuer ein gutes Buch fuer mich? Gruss, Max
\end{quote}

\subsection{AdvaziCrypt - Denksport}
Wenn wir davon ausgehen, dass der Key vollständig (wenn auch `verschlüsselt') in der Datei vorhanden ist,
dann sind auf jeden Fall die letzten 10 Bytes des Ciphertexts die verschlüsselten Key-Bytes. Jetzt kann man
auf die Anzahl der Padding-Bytes schließen, indem man darauf achtet, wann die hinteren Bytes aufhören, Teil
des vermeintlichen, verschlüsselten Keys zu sein. Man zählt also mit und schaut, wann ein Byte nicht mehr passt.
Für die genaue Implementation, siehe unser Skript im Appendix.

\subsection{AdvaziCrypt}
Die Plaintexte lauten:
\begin{quote}[n04.txt.enc]
Hi Max, natuerlich: Kryptologie von A. Beutelspacher ist super. Gruss Peter
\end{quote}
\begin{quote}[n05.txt.enc]
Hi Peter, worum geht es in dem Buch? Ciao, Max.
\end{quote}
\begin{quote}[n06.txt.enc]
Hi Max, das ist ein super Buch, das viele Krypto-Themen abdeckt. Gruss Peter
\end{quote}

\newpage
\section*{Appendix}
\subsection{3. Skripte}
\subsubsection*{Bazi Crack}
\inputminted{python}{crack_bazi.py}

\newpage

\subsubsection*{Advazi Crack}
\inputminted{python}{crack_advazi.py}

\end{document}
