\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{minted}
\usepackage[left=2cm, right=2cm]{geometry}
\usepackage{url}


\setcounter{section}{1}
\author{Tronje Krabbe, Julian Deinert}
\title{Labreport 02}
\begin{document}
\maketitle
\tableofcontents
\newpage


\section*{Aufgabe 1 HTTP}
\addcontentsline{toc}{section}{Aufgabe 1 HTTP}
\subsection{Telnet}
Wir haben versucht uns mit dem Befehl \texttt{telnet} mit dem angegebenen Server zu verbinden.
\begin{minted}{bash}
$ telnet www.inf.uni-hamburg.de 80                                                                       
Trying 134.100.56.130...
Connected to www.inf.uni-hamburg.de.
Escape character is '^]'.

GET /de/inst/ab/svs/home.html HTTP/1.1
\end{minted}
Als Antwort auf unseren GET-Request erhalten wir eine Website mit Returncode \texttt{302 Found}, die uns sagt, dass das Dokument nur mittels \textit{https} erreichbar ist. Da Telnet kein https kann, greifen wir auf openssl zurück.
\begin{minted}{bash}
$ openssl s_client -connect www.inf.uni-hamburg.de:443

GET /de/inst/ab/svs/home.html HTTP/1.1

\end{minted}
Wir erhalten den HTTP-Fehlercode \texttt{400 Bad Request} zurück. Dementsprechend können wir auch keine CSS-Dateien anfordern.

\setcounter{section}{2}
\setcounter{subsection}{0}
\section*{Aufgabe 2 SMTP}
\addcontentsline{toc}{section}{Aufgabe 2 SMTP}
\subsection{Mail Spoofing}
Wir verbinden uns mittels \textit{Netcat} mit dem Mailserver \texttt{mailhost.informatik.uni-hamburg.de} auf Port 25. Nach dem wir die Felder \texttt{FROM}, \texttt{RCPT TO} sowie \texttt{DATA} gesetzt haben wird unsere Mail erfolgreich versendet.
Der Empfänger kann anhand des Quelltextes erkennen, dass die Mail nicht von einem \textit{Authenticated sender} geschickt wurde.\\
Es gibt keinen Unterschied ziwschen einer gespooften gmail oder informatik.uni-hamnburg Adresse, da beide Mails direkt beim Mailhost eingereicht wurden.

\setcounter{section}{3}
\setcounter{subsection}{0}
\section*{Aufgabe 3 License Server}
\addcontentsline{toc}{section}{Aufgabe 2 License Server}
\subsection{DNS Spoofing}
Wir haben uns mit \textit{netcat} zum Server verbunden und werden aufgefordert einen von 4 validen Commands einzugeben. Diese sind:
\begin{itemize}
\item help
\item serial
\item version
\item quit
\end{itemize}
Wenn wir eine Serial angeben, die zufällig keine gültige ist, bekommen wir die Meldung \texttt{SERIAL\_VALID=0} zurück. Anhand dieser Information erstellen wir unseren TCP server so, dass bei jeder Serial die Meldung \texttt{SERIAL\_VALID=1} zurückgegeben wird.
\subsection{Eigener License Server}
\begin{minted}{python}
#!/usr/bin/env python
import socketserver as ss

class LeetTCPHandler(ss.BaseRequestHandler):
    def handle(self):
        self.data = self.request.recv(1024).strip()
        print(self.data)
        if self.data == b'VERSION':
            self.request.sendall(b"Numeric Serial Server Validation System 2.1a")
        elif self.data[:6] == b'SERIAL':
            self.request.sendall(b"SERIAL_VALID=1")
        else:
            self.request.sendall(b"Invalid command")


if __name__ == "__main__":
    HOST, PORT = "localhost", 1337

    server = ss.TCPServer((HOST, PORT), LeetTCPHandler)

    server.serve_forever()
\end{minted}

Außerdem ergänzen wir unser Host-File um diese Zeile:\\
\texttt{127.0.0.1 license-server.svslab localhost} \\
Nun können wir das Java-Programm ausführen, und es verbindet sich mit unserem
eigenen TCP-Server, und akzeptiert eine beliebige Zahl als License-Key:
\begin{verbatim}
Your license has expired - please enter new license key!
To order your new key for just 999.99$ call +1-555-we-rule

Key: 123
Numeric Serial Server Validation Sy
Thanks for purchasing a new license!
\end{verbatim}

\subsection{Verhinderung des Angriffs}
Eine naive Möglichkeit, den Spoof zu entdecken, wäre einfach, ein weniger offensichtiliches
Schlüsselwort als Ausgabe nach erfolgreicher Überprüfung zu wählen. Momentan gibt
der Server \textit{SERIAL\_VALID=0} zurück, wenn der Key falsch ist.
Daraus ist leicht zu folgern, dass \textit{SERIAL\_VALID=1} die Ausgabe ist, die
bei einem richtigen Key gegeben wird. Dies könnte man ändern um den Angriff
zu erschweren.

Eine sicherere Methode wäre, Public-Key-Cryptographie zu nutzen. Das Programm wird
mit dem public-key des Servers sowie seinem eigenen private-key kompiliert.
Der Server kennt den public-key des Programms. Die Kommunikation geschieht so,
dass alles, was das Programm an den Server sendet, mit seinem public-key verschlüsselt ist.
Der Server entschlüsselt die erhaltenen Daten mit seinem private-key, und
verschlüsselt seine Ausgabe mit dem public-key des Programms.

Auch hier liegt leider eine Schwierigkeit; hat jede Kopie des Programms das gleiche
Key-Paar? Wenn nicht, woher weiß der Server, welchen Key er benutzen muss?
Außerdem könnte man den Speicher des Programms untersuchen, während es läuft,
oder einen Decompiler benutzen, um die Keys zu finden.

\section{Aufgabe 4 License-Server}
TODO
\end{document}
